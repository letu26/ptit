<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>C·∫•u tr√∫c d·ªØ li·ªáu & Thu·∫≠t to√°n</title>

    <style>
        
        .copy-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            padding: 6px 10px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #ccc;
            background: #fff;
        }

        .copy-btn:hover {
            background: #eaeaea;
        }
    </style>
</head>

<body>
<details>
    <summary>1. AVL Tree</summary>
    <button class="copy-btn" onclick="copyFromDetails(this)">üìã</button>

<pre><code>
package hihi;

import java.util.Scanner;

class AVLTree {
    class Node {
        int key, height;
        Node left, right;

        Node(int d) {
            key = d;
            height = 1;
        }
    }

    Node root;

    int height(Node N) {
        if (N == null) return 0;
        return N.height;
    }

    int max(int a, int b) {
        return (a > b) ? a : b;
    }

    int getBalance(Node N) {
        if (N == null) return 0;
        return height(N.left) - height(N.right);
    }

    Node rightRotate(Node y) {
        System.out.println("Th·ª±c hi·ªán Right Rotate t·∫°i node " + y.key);
        Node x = y.left;
        Node T2 = x.right;

        x.right = y;
        y.left = T2;

        y.height = max(height(y.left), height(y.right)) + 1;
        x.height = max(height(x.left), height(x.right)) + 1;

        return x;
    }

    Node leftRotate(Node x) {
        System.out.println("Th·ª±c hi·ªán Left Rotate t·∫°i node " + x.key);
        Node y = x.right;
        Node T2 = y.left;

        y.left = x;
        x.right = T2;

        x.height = max(height(x.left), height(x.right)) + 1;
        y.height = max(height(y.left), height(y.right)) + 1;

        return y;
    }

    Node insert(Node node, int key) {
        if (node == null)
            return new Node(key);

        if (key < node.key)
            node.left = insert(node.left, key);
        else if (key > node.key)
            node.right = insert(node.right, key);
        else {
            System.out.println("‚ö† Gi√° tr·ªã " + key + " ƒë√£ t·ªìn t·∫°i!");
            return node;
        }

        node.height = 1 + max(height(node.left), height(node.right));

        int balance = getBalance(node);

        // LL
        if (balance > 1 && key < node.left.key)
            return rightRotate(node);

        // RR
        if (balance < -1 && key > node.right.key)
            return leftRotate(node);

        // LR
        if (balance > 1 && key > node.left.key) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }

        // RL
        if (balance < -1 && key < node.right.key) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }

        return node;
    }

    void insert(int key) {
        root = insert(root, key);
    }

    void inorder(Node node) {
        if (node != null) {
            inorder(node.left);
            System.out.print(node.key + " ");
            inorder(node.right);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        AVLTree tree = new AVLTree();

        System.out.print("Nh·∫≠p s·ªë l∆∞·ª£ng ph·∫ßn t·ª≠: ");
        int n = sc.nextInt();

        for (int i = 0; i < n; i++) {
            System.out.print("Nh·∫≠p gi√° tr·ªã th·ª© " + (i + 1) + ": ");
            int key = sc.nextInt();

            System.out.println("\nCh√®n " + key + ":");
            tree.insert(key);

            System.out.print("C√¢y hi·ªán t·∫°i (Inorder): ");
            tree.inorder(tree.root);
            System.out.println("\n-----------------------");
        }

        sc.close();
    }
}
</code></pre>
</details>
<details>
    <summary>2. Dijkstra-T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t (Danh s√°ch k·ªÅ)</summary>
    <button class="copy-btn" onclick="copyFromDetails(this)">üìã </button>

<pre><code>
package hihi;

import java.util.*;

public class DijkstraInput {
  static class Edge {
    int to, weight;

    Edge(int to, int weight) {
      this.to = to;
      this.weight = weight;
    }
  }

  static class Node implements Comparable<Node> {
    int vertex, dist;

    Node(int vertex, int dist) {
      this.vertex = vertex;
      this.dist = dist;
    }

    public int compareTo(Node other) {
      return Integer.compare(this.dist, other.dist);
    }
  }

  static void dijkstra(List<List<Edge>> graph, int start) {
    int n = graph.size();
    int[] dist = new int[n];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[start] = 0;

    PriorityQueue<Node> pq = new PriorityQueue<>();
    pq.add(new Node(start, 0));

    while (!pq.isEmpty()) {
      Node current = pq.poll();
      int u = current.vertex;

      for (Edge edge : graph.get(u)) {
        int v = edge.to;
        int weight = edge.weight;

        if (dist[u] + weight < dist[v]) {
          dist[v] = dist[u] + weight;
          pq.add(new Node(v, dist[v]));
        }
      }
    }

    System.out.println("Kho·∫£ng c√°ch t·ª´ ƒë·ªânh " + start + ":");
    for (int i = 0; i < n; i++) {
      System.out.println("‚Üí ƒë·∫øn " + i + " = " + dist[i]);
    }
  }

  public static void main(String[] args) {
    try (Scanner sc = new Scanner(System.in)) {
      System.out.print("Nh·∫≠p s·ªë ƒë·ªânh: ");
      int n = sc.nextInt();

      System.out.print("Nh·∫≠p s·ªë c·∫°nh: ");
      int m = sc.nextInt();

      List<List<Edge>> graph = new ArrayList<>();
      for (int i = 0; i < n; i++)
        graph.add(new ArrayList<>());

      System.out.println("Nh·∫≠p c√°c c·∫°nh theo d·∫°ng: u v w (u ƒë·∫øn v, tr·ªçng s·ªë w)");
      for (int i = 0; i < m; i++) {
        int u = sc.nextInt();
        int v = sc.nextInt();
        int w = sc.nextInt();
        graph.get(u).add(new Edge(v, w));
        // N·∫øu ƒë·ªì th·ªã v√¥ h∆∞·ªõng th√¨ th√™m d√≤ng sau:
        // graph.get(v).add(new Edge(u, w));
      }

      System.out.print("Nh·∫≠p ƒë·ªânh b·∫Øt ƒë·∫ßu: ");
      int start = sc.nextInt();

      dijkstra(graph, start);
    }
  }
}
// input
// Nh·∫≠p s·ªë ƒë·ªânh: 6
// Nh·∫≠p s·ªë c·∫°nh: 7
// Nh·∫≠p c√°c c·∫°nh:
// 0 1 4
// 0 2 1
// 2 1 2
// 1 3 1
// 2 3 5
// 3 4 3
// 4 5 1
// Nh·∫≠p ƒë·ªânh b·∫Øt ƒë·∫ßu: 0

// output
// Kho·∫£ng c√°ch t·ª´ ƒë·ªânh 0:
// ‚Üí ƒë·∫øn 0 = 0
// ‚Üí ƒë·∫øn 1 = 3
// ‚Üí ƒë·∫øn 2 = 1
// ‚Üí ƒë·∫øn 3 = 4
// ‚Üí ƒë·∫øn 4 = 7
// ‚Üí ƒë·∫øn 5 = 8
</code></pre>
</details>
<details>
    <summary>3. Segment Tree (Update + Query Sum)</summary>
    <button class="copy-btn" onclick="copyFromDetails(this)">üìã </button>
<pre><code>
package hihi;

import java.util.Scanner;

class SegmentTree {
    int n;
    int[] tree;

    // Kh·ªüi t·∫°o t·ª´ m·∫£ng ban ƒë·∫ßu
    SegmentTree(int[] arr) {
        n = arr.length;
        tree = new int[4 * n];
        build(arr, 1, 0, n - 1);
    }

    // X√¢y d·ª±ng c√¢y
    void build(int[] arr, int node, int l, int r) {
        if (l == r) {
            tree[node] = arr[l];
        } else {
            int mid = (l + r) / 2;
            build(arr, 2 * node, l, mid);
            build(arr, 2 * node + 1, mid + 1, r);
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    }

    // Query sum tr√™n ƒëo·∫°n [ql, qr]
    int query(int node, int l, int r, int ql, int qr) {
        if (qr < l || ql > r) return 0;
        if (ql <= l && r <= qr) return tree[node];
        int mid = (l + r) / 2;
        return query(2 * node, l, mid, ql, qr)
             + query(2 * node + 1, mid + 1, r, ql, qr);
    }

    int query(int ql, int qr) {
        return query(1, 0, n - 1, ql, qr);
    }

    // Update
    void update(int node, int l, int r, int idx, int val) {
        if (l == r) {
            tree[node] = val;
        } else {
            int mid = (l + r) / 2;
            if (idx <= mid)
                update(2 * node, l, mid, idx, val);
            else
                update(2 * node + 1, mid + 1, r, idx, val);

            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    }

    void update(int idx, int val) {
        update(1, 0, n - 1, idx, val);
    }

    // ================= MAIN =================
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Nh·∫≠p m·∫£ng
        System.out.print("Nh·∫≠p s·ªë ph·∫ßn t·ª≠: ");
        int n = sc.nextInt();
        int[] arr = new int[n];

        System.out.println("Nh·∫≠p c√°c ph·∫ßn t·ª≠:");
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        SegmentTree st = new SegmentTree(arr);

        // Menu
        while (true) {
            System.out.println("\n===== MENU =====");
            System.out.println("1. Query t·ªïng ƒëo·∫°n [l, r]");
            System.out.println("2. Update gi√° tr·ªã t·∫°i v·ªã tr√≠ idx");
            System.out.println("0. Tho√°t");
            System.out.print("Ch·ªçn: ");

            int choice = sc.nextInt();

            if (choice == 0) {
                System.out.println("ƒê√£ tho√°t ch∆∞∆°ng tr√¨nh.");
                break;
            }

            switch (choice) {
                case 1:
                    System.out.print("Nh·∫≠p l: ");
                    int l = sc.nextInt();
                    System.out.print("Nh·∫≠p r: ");
                    int r = sc.nextInt();
                    System.out.println("T·ªïng [" + l + "," + r + "] = " + st.query(l, r));
                    break;

                case 2:
                    System.out.print("Nh·∫≠p v·ªã tr√≠ idx: ");
                    int idx = sc.nextInt();
                    System.out.print("Nh·∫≠p gi√° tr·ªã m·ªõi: ");
                    int val = sc.nextInt();
                    st.update(idx, val);
                    System.out.println("ƒê√£ update!");
                    break;

                default:
                    System.out.println("L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!");
            }
        }

        sc.close();
    }
}
</code></pre>
</details>
<details>
    <summary>4. QuickSort & MergeSort</summary>
    <button class="copy-btn" onclick="copyFromDetails(this)">üìã </button>
<pre><code>
package hihi;

import java.util.*;

public class SortCompare {
    // QuickSort
    static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
            }
        }
        int tmp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = tmp;
        return i + 1;
    }

    // MergeSort
    static void mergeSort(int[] arr, int l, int r) {
        if (l < r) {
            int m = (l + r) / 2;
            mergeSort(arr, l, m);
            mergeSort(arr, m + 1, r);
            merge(arr, l, m, r);
        }
    }

    static void merge(int[] arr, int l, int m, int r) {
        int n1 = m - l + 1;
        int n2 = r - m;
        int[] L = new int[n1];
        int[] R = new int[n2];
        for (int i = 0; i < n1; i++) L[i] = arr[l + i];
        for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];

        int i = 0, j = 0, k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) arr[k++] = L[i++];
            else arr[k++] = R[j++];
        }
        while (i < n1) arr[k++] = L[i++];
        while (j < n2) arr[k++] = R[j++];
    }

    public static void main(String[] args) {
        int n = 1_000_000;
        Random rand = new Random();

        // T·∫°o m·∫£ng ng·∫´u nhi√™n
        int[] arr1 = new int[n];
        for (int i = 0; i < n; i++) arr1[i] = rand.nextInt(1_000_000);

        // Copy cho MergeSort
        int[] arr2 = Arrays.copyOf(arr1, n);

        // QuickSort
        long start = System.currentTimeMillis();
        quickSort(arr1, 0, n - 1);
        long end = System.currentTimeMillis();
        System.out.println("QuickSort time: " + (end - start) + " ms");

        // MergeSort
        start = System.currentTimeMillis();
        mergeSort(arr2, 0, n - 1);
        end = System.currentTimeMillis();
        System.out.println("MergeSort time: " + (end - start) + " ms");
    }
}
</code></pre>
</details>
<details>
    <summary>5. LIS O(n log n)</summary>
    <button class="copy-btn" onclick="copyFromDetails(this)">üìã</button>
<pre><code>
package hihi;
import java.util.*;
public class LIS {
    static List<Integer> lisSequence(int[] arr) {
        int n = arr.length;
        int[] tail = new int[n];     // l∆∞u gi√° tr·ªã
        int[] pos = new int[n];      // l∆∞u v·ªã tr√≠ trong arr
        int[] prev = new int[n];     // truy v·∫øt ph·∫ßn t·ª≠ tr∆∞·ªõc
        Arrays.fill(prev, -1);

        int length = 0;

        for (int i = 0; i < n; i++) {
            int x = arr[i];
            // t√¨m v·ªã tr√≠ ch√®n b·∫±ng binary search
            int idx = Arrays.binarySearch(tail, 0, length, x);
            if (idx < 0) idx = -(idx + 1);

            tail[idx] = x;
            pos[idx] = i;

            if (idx > 0) prev[i] = pos[idx - 1];
            if (idx == length) length++;
        }

        // Truy ng∆∞·ª£c ƒë·ªÉ d·ª±ng LIS
        List<Integer> lis = new ArrayList<>();
        int p = pos[length - 1];
        while (p != -1) {
            lis.add(arr[p]);
            p = prev[p];
        }
        Collections.reverse(lis);
        return lis;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Nh·∫≠p s·ªë ph·∫ßn t·ª≠: ");
        int n = sc.nextInt();
        int[] arr = new int[n];

        System.out.println("Nh·∫≠p m·∫£ng:");
        for (int i = 0; i < n; i++) arr[i] = sc.nextInt();

        List<Integer> lis = lisSequence(arr);
        System.out.println("ƒê·ªô d√†i LIS = " + lis.size());
        System.out.println("D√£y LIS: " + lis);
    }
}
</code></pre>
</details>
<details>
    <summary>6. Dijkstra-T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t (Ma tr·∫≠n k·ªÅ)</summary>
    <button class="copy-btn" onclick="copyFromDetails(this)">üìã </button>

<pre><code>
package hihi;

import java.util.*;

public class DijkstraMatrix {

    static final int INF = 1_000_000_000;

    static void dijkstra(int[][] graph, int start) {
        int n = graph.length;
        int[] dist = new int[n];
        boolean[] visited = new boolean[n];

        Arrays.fill(dist, INF);
        dist[start] = 0;

        for (int i = 0; i < n - 1; i++) {
            // T√¨m ƒë·ªânh ch∆∞a thƒÉm c√≥ dist nh·ªè nh·∫•t
            int u = -1;
            int min = INF;

            for (int v = 0; v < n; v++) {
                if (!visited[v] && dist[v] < min) {
                    min = dist[v];
                    u = v;
                }
            }

            if (u == -1) break;

            visited[u] = true;

            // C·∫≠p nh·∫≠t c√°c ƒë·ªânh k·ªÅ
            for (int v = 0; v < n; v++) {
                if (!visited[v]
                        && graph[u][v] > 0        // c√≥ c·∫°nh
                        && dist[u] + graph[u][v] < dist[v]) {

                    dist[v] = dist[u] + graph[u][v];
                }
            }
        }

        System.out.println("Kho·∫£ng c√°ch ng·∫Øn nh·∫•t t·ª´ ƒë·ªânh " + start + ":");
        for (int i = 0; i < n; i++) {
            System.out.println("‚Üí ƒë·∫øn " + i + " = " + dist[i]);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Nh·∫≠p s·ªë ƒë·ªânh: ");
        int n = sc.nextInt();

        int[][] graph = new int[n][n];

        System.out.println("Nh·∫≠p ma tr·∫≠n k·ªÅ:");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                graph[i][j] = sc.nextInt();
            }
        }

        System.out.print("Nh·∫≠p ƒë·ªânh b·∫Øt ƒë·∫ßu: ");
        int start = sc.nextInt();

        dijkstra(graph, start);
        sc.close();
    }
}
//Input
//Nh·∫≠p s·ªë ƒë·ªânh: 6
//Nh·∫≠p ma tr·∫≠n k·ªÅ (0 = kh√¥ng c√≥ c·∫°nh):
//0 7 9 0 0 14
//0 0 10 15 0 0
//0 0 0 11 0 2
//0 0 0 0 6 0
//0 0 0 0 0 0
//0 0 0 0 0 0
//Nh·∫≠p ƒë·ªânh b·∫Øt ƒë·∫ßu: 0
//Output
//Kho·∫£ng c√°ch ng·∫Øn nh·∫•t t·ª´ ƒë·ªânh 0:
//‚Üí ƒë·∫øn 0 = 0
//‚Üí ƒë·∫øn 1 = 7
//‚Üí ƒë·∫øn 2 = 9
//‚Üí ƒë·∫øn 3 = 20
//‚Üí ƒë·∫øn 4 = 26
//‚Üí ƒë·∫øn 5 = 11
</code></pre>
</details>

<script>
function copyFromDetails(btn) {
    const details = btn.closest("details");
    const code = details.querySelector("code").innerText;

    navigator.clipboard.writeText(code).then(() => {
        btn.innerText = "‚úÖ Copied";
        setTimeout(() => btn.innerText = "üìã Copy", 1500);
    });
}
</script>

</body>
</html>
